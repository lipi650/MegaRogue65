10 rem --- variables, arrays ---
20 dim rm(4,4): dim ma(4,4): dim vs(4,4): dim pr(4,4)
25 dim fx(25): dim fy(25)
   50 dim r(32):dim g(32): dim b(32): rem palette values
   90 mem 1,3: screen clr
   95 goto 120
  100 gosub 7000 :rem load palette
  105 bload"fcmchrs.chr",p($40000)
  110 rem edma 0,64000,$8000000,$40000
  115 gosub 5000: rem setup fcm-rrb environment
  120 gosub 9000: rem set starting room and generate 5x5 map
  130 rem gosub 6500: rem  draw map
  870 getkey a$
  874 gosub 5250: rem reset settings
  875 palette restore
  900 end
 4999 rem =========setup rrb environment===========
 5000 s1=wpeek($d062):s2=wpeek($d060): rem store screen pointer
 5010 rem ==== enable seam mode ====
 5020 setbit $d054,2: setbit $d054,0 :rem fclrhi, chr16
 5030 clrbit $d031,7: poke$d058,160:  rem set 40 column mode
 5040 wpoke $d060,$0000: wpoke $d062,$5:rem set screen pointer to $50000
 5050 cc=wpeek($d05e)
 5060 poke $d05e, 80: rem set chrcnt
 5070 rem ==========================
 5080 for i=0to1999*2 step2 :wpoke$50000+i,$0020:nexti:rem fill the whole screen.
 5090 for i=0to1999*2 step2 :wpoke$ff80000+i,$0300:nexti:rem fill colour ram
 5100 getkey a$
 5110 rem === gotox ($0090) move to column 40 ($28)
 5112 rem need to put a for-next loop to do it for all rows
 5120 wpoke $50050,$0028
 5130 wpoke $ff80050,$0090
 5140 rem ===layer a new character on the already printed one
 5150 wpoke $50052,$1000 : wpoke $50054,$1001 : wpoke $50056,$1002: wpoke $50058,$1003: wpoke $5005a,$1004: wpoke $5005c,$1005
 5152 wpoke $5005e,$1006 : wpoke $50060,$1007 :wpoke $50062,$1028: wpoke $50064,$1029
 5160 wpoke $ff80052,$0100
 5170 rem === close the line by gotox and position to the far right
 5180 rem === the line can be closed anywhere earlier (eg. from $50054)
 5190 wpoke $50096,$0140
 5200 wpoke $50098,$0000
 5210 wpoke $ff80096,$0010
 5220 wpoke $ff80098,$0000
 5225 return
 5230 getkey a$
 5240 rem ===== reset settings =====
 5250 wpoke $d060,$800: wpoke$d062,$0000
 5260 clrbit $d054,2: clrbit $d054,0 :rem fclrhi, chr16
 5270 setbit $d031,7: poke$d058,80 :rem 80 column mode
 5280 return
 6901 rem ------------------------------
 6999 rem === load palette
 7000 dopen#5,"palette32.pal"
 7010 i=0
 7020 do while i<32
 7030 get#5,r$,g$,b$
 7040 palette color i,asc(r$),asc(g$),asc(b$)
 7050 i=i+1
 7060 loop
 7070 dclose#5
 7080 return
 7090 rem ------------------------------

9000 rem ---- starting room ----
9005 sx=int(rnd(0)*5): sy=int(rnd(0)*5)

9010 rem ---- initialize mask ----
9015 for y1=0 to 4
9020 for x1=0 to 4
9025 ma(x1,y1)=0: vs(x1,y1)=0: pr(x1,y1)=0: rm(x1,y1)=0
9030 if x1>0 then ma(x1,y1)=ma(x1,y1) or 8
9035 if x1<4 then ma(x1,y1)=ma(x1,y1) or 2
9040 if y1<4 then ma(x1,y1)=ma(x1,y1) or 4
9045 if y1>0 then ma(x1,y1)=ma(x1,y1) or 1
9050 next x1
9055 next y1

9060 rem ---- random room removal ----
9065 nr=int(rnd(0)*7)+5 : print "removed rooms aim:" nr
9070 for i=1 to nr
9075 do
9080   xx=int(rnd(0)*5): yy=int(rnd(0)*5)
9085 loop until (xx<>sx or yy<>sy) and ma(xx,yy)<>0

9090 rem ---- save old masks ----
9095 om=ma(xx,yy)
9100 if xx>0 then oe=ma(xx-1,yy)
9105 if xx<4 then ow=ma(xx+1,yy)
9110 if yy>0 then os=ma(xx,yy-1)
9115 if yy<4 then nn=ma(xx,yy+1)

9120 rem ---- remove room ----
9125 ma(xx,yy)=0
9130 if xx>0 then ma(xx-1,yy)=ma(xx-1,yy) and 13
9135 if xx<4 then ma(xx+1,yy)=ma(xx+1,yy) and 14
9140 if yy>0 then ma(xx,yy-1)=ma(xx,yy-1) and 11
9145 if yy<4 then ma(xx,yy+1)=ma(xx,yy+1) and 7

9150 rem ---- connectivity check ----
9155 for y2=0 to 4: for x2=0 to 4: vs(x2,y2)=0: next x2: next y2
9160 sc=1: fx(sc)=sx: fy(sc)=sy: vs(sx,sy)=1
9165 do while sc<>0
9170   cx=fx(sc): cy=fy(sc): sc=sc-1

9175   rem north
9180   if cy>0 then begin
9185     if ma(cx,cy) and 1 then begin
9190       if ma(cx,cy-1)<>0 then begin
9195         if vs(cx,cy-1)=0 then begin
9200           sc=sc+1
9205           fx(sc)=cx: fy(sc)=cy-1
9210           vs(cx,cy-1)=1
9215         bend
9220       bend
9225     bend
9230   bend

9235   rem east
9240   if cx<4 then begin
9245     if ma(cx,cy) and 2 then begin
9250       if ma(cx+1,cy)<>0 then begin
9255         if vs(cx+1,cy)=0 then begin
9260           sc=sc+1
9265           fx(sc)=cx+1: fy(sc)=cy
9270           vs(cx+1,cy)=1
9275         bend
9280       bend
9285     bend
9290   bend

9295   rem south
9300   if cy<4 then begin
9305     if ma(cx,cy) and 4 then begin
9310       if ma(cx,cy+1)<>0 then begin
9315         if vs(cx,cy+1)=0 then begin
9320           sc=sc+1
9325           fx(sc)=cx: fy(sc)=cy+1
9330           vs(cx,cy+1)=1
9335         bend
9340       bend
9345     bend
9350   bend

9355   rem west
9360   if cx>0 then begin
9365     if ma(cx,cy) and 8 then begin
9370       if ma(cx-1,cy)<>0 then begin
9375         if vs(cx-1,cy)=0 then begin
9380           sc=sc+1
9385           fx(sc)=cx-1: fy(sc)=cy
9390           vs(cx-1,cy)=1
9395         bend
9400       bend
9405     bend
9410   bend

9415 loop

9420 rem ---- check connectivity ----
9425 fail=0
9430 for y2=0 to 4: for x2=0 to 4
9435   if ma(x2,y2)<>0 and vs(x2,y2)=0 then fail=1
9440 next x2: next y2

9445 rem ---- undo removal if disconnected ----
9450 if fail=1 then begin
9455   ma(xx,yy)=om
9460   if xx>0 then ma(xx-1,yy)=oe
9465   if xx<4 then ma(xx+1,yy)=ow
9470   if yy>0 then ma(xx,yy-1)=os
9475   if yy<4 then ma(xx,yy+1)=nn
9480 bend

9485 next i

9490 rem ---- dfs-based door assignment with full mirroring ----
9495 for y2=0 to 4: for x2=0 to 4: vs(x2,y2)=0: rm(x2,y2)=0: pr(x2,y2)=0: next x2: next y2
9500 sp=1: fx(sp)=sx: fy(sp)=sy: vs(sx,sy)=1

9505 do while sp<>0
9510   cx=fx(sp): cy=fy(sp): sp=sp-1

9520 rem ---- connect neighbors with full mirroring ----

9525   rem north
9530   if cy>0 then begin
9535     if ma(cx,cy) and 1 then begin
9540       if ma(cx,cy-1)<>0 then begin
9545         rm(cx,cy)=rm(cx,cy) or 1
9550         rm(cx,cy-1)=rm(cx,cy-1) or 4
9555       bend
9560     bend
9565   bend

9570   rem east
9575   if cx<4 then begin
9580     if ma(cx,cy) and 2 then begin
9585       if ma(cx+1,cy)<>0 then begin
9590         rm(cx,cy)=rm(cx,cy) or 2
9595         rm(cx+1,cy)=rm(cx+1,cy) or 8
9600       bend
9605     bend
9610   bend

9615   rem south
9620   if cy<4 then begin
9625     if ma(cx,cy) and 4 then begin
9630       if ma(cx,cy+1)<>0 then begin
9635         rm(cx,cy)=rm(cx,cy) or 4
9640         rm(cx,cy+1)=rm(cx,cy+1) or 1
9645       bend
9650     bend
9655   bend

9660   rem west
9665   if cx>0 then begin
9670     if ma(cx,cy) and 8 then begin
9675       if ma(cx-1,cy)<>0 then begin
9680         rm(cx,cy)=rm(cx,cy) or 8
9685         rm(cx-1,cy)=rm(cx-1,cy) or 2
9690       bend
9695     bend
9700   bend

9705 rem ---- push unvisited neighbors ----
9710   rem north
9715   if cy>0 then begin
9720     if ma(cx,cy) and 1 then begin
9725       if ma(cx,cy-1)<>0 then begin
9730         if vs(cx,cy-1)=0 then begin
9735           sp=sp+1
9740           fx(sp)=cx: fy(sp)=cy-1
9745           vs(cx,cy-1)=1
9750         bend
9755       bend
9760     bend
9765   bend

9770   rem east
9775   if cx<4 then begin
9780     if ma(cx,cy) and 2 then begin
9785       if ma(cx+1,cy)<>0 then begin
9790         if vs(cx+1,cy)=0 then begin
9795           sp=sp+1
9800           fx(sp)=cx+1: fy(sp)=cy
9805           vs(cx+1,cy)=1
9810         bend
9815       bend
9820     bend
9825   bend

9830   rem south
9835   if cy<4 then begin
9840     if ma(cx,cy) and 4 then begin
9845       if ma(cx,cy+1)<>0 then begin
9850         if vs(cx,cy+1)=0 then begin
9855           sp=sp+1
9860           fx(sp)=cx: fy(sp)=cy+1
9865           vs(cx,cy+1)=1
9870         bend
9875       bend
9880     bend
9885   bend

9890   rem west
9895   if cx>0 then begin
9900     if ma(cx,cy) and 8 then begin
9905       if ma(cx-1,cy)<>0 then begin
9910         if vs(cx-1,cy)=0 then begin
9915           sp=sp+1
9920           fx(sp)=cx-1: fy(sp)=cy
9925           vs(cx-1,cy)=1
9930         bend
9935       bend
9940     bend
9945   bend

9950 vs(cx,cy)=1
9955 pr(cx,cy)=1

9960 loop
9962 return
9965 rem ---- print map ----
9970 print "sx:";sx;" sy:";sy
9975 for y1=0 to 4
9980 for x1=0 to 4
9985 print rm(x1,y1);
9990 next x1
9995 print
10000 next y1

